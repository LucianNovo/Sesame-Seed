<html>
  <head>
    <script src="assets/js/Three.js"></script>
    <style type="text/css">
      body {
        margin: 0px;
        padding: 0px;
      }

      #container {
        position:absolute;
        left:0px;
        top:0px;
        width:100%;
        height:100%;
        margin: 0px;
        padding: 0px;
      }
    </style>

    <script src="assets/js/raf.js"></script>
    <script src="assets/js/dat-gui/build/DAT.GUI.min.js"></script>

  </head>

  <body>
    <script type="text/javascript">

    var planets;
    var spheres;
    var speeds = [ .15,.25, .35, .4, .5, .6, .75, .85, 1, 1.15, 1.25, 1.5];
    var cycles = [ .7, .75, .80, .85, .90, .95, 1.0, 1.05, 1.1, 1.15, 1.20, 1.25];
    var speed;
    var rotation = 1;
    var ss = {"angle": 90, "angleIncrement":0.03, "amplitude": 100, "cycles":1,"period":1,"verticalShift": 0, "horizontalShift": 0
      // ,
      // this.radiateCenter = function(){

      // }

    };

    // Creating the cube
      var renderer = new THREE.WebGLRenderer({antialias: true, alpha: true});
      renderer.setSize(document.body.clientWidth, document.body.clientHeight);
      document.body.appendChild(renderer.domElement);
      // renderer.setClearColorHex(0xFFFFFF, 1.0);
      renderer.setClearColor( 0x0000000, 1);
      renderer.clear();

      var fov = 45;
      var width  = renderer.domElement.width; 
      var height = renderer.domElement.height;

      var aspect = width/height;

      var near = 1;
      var far = 10000;

      var camera = new THREE.PerspectiveCamera(fov, aspect, near, far);
      camera.position.z = 300;

      var scene = new THREE.Scene();
      var cube  = new THREE.Mesh(
        new THREE.CubeGeometry(30,30,30),
        new THREE.MeshBasicMaterial({color: 0xCCCCCC, opacity: 1})
      );
      scene.add(cube);
      renderer.render(scene, camera);

  // Creating the light

      var dirLight = new THREE.DirectionalLight( 0xffffff, 0.125 );
      dirLight.position.set( 0, -1, 0 ).normalize();
      scene.add( dirLight );

      dirLight.color.setHSL( 0.1, 0.7, 0.5 );
        
      // var light = new THREE.SpotLight();
      // light.position.set(0,100,0);
      // light.castShadow = true;
      // scene.add(light);

      // var litCube = new THREE.Mesh(
      //   new THREE.CubeGeometry(50, 50, 50),
      //   new THREE.MeshLambertMaterial({color: 0xffffff}));
      
  // scene.add(litCube);

      // var geometry = new THREE.SphereGeometry( 5, 32, 32 );
      // var material = new THREE.MeshBasicMaterial( {color: Number("0xEC5519")} );
      // var sphere = new THREE.Mesh( geometry, material );
      // scene.add( sphere );

      // var rand   = myArray[Math.floor(Math.random() * myArray.length)];

    var RADIUS = 30;
    var relatives = [1, -1];
    var sizes  = [7, 8, 9, 10, 11];
    var kuler = ["0x32450C", "0x717400", "0xDC8505", "0xEC5519", "0xBE2805"];

    function createPlanets(){
        var PLANET_COUNT = 40;
        planets = []; // reference from global
        spheres = []; // reference from global
        for(var i=0; i<PLANET_COUNT; i++){
          var geometry   = new THREE.SphereGeometry( sizes[Math.floor(Math.random() * sizes.length)], 8, 8 );
          var material   = new THREE.MeshBasicMaterial( {color: Number(kuler[Math.floor(Math.random() * kuler.length)])});
          spheres[i]     = new THREE.Mesh( geometry, material );
          scene.add(spheres[i]);
          // spheres.push( sphere );

          var planet = {
            speed: speeds[Math.floor(Math.random() * speeds.length)],
            relative: relatives[Math.floor(Math.random() * relatives.length)],
            random: Math.random() * speeds[speeds.length-1],
            cycle: cycles[Math.floor(Math.random() * cycles.length)],
            targetSize: 1,
            orbit: RADIUS*.5 + (RADIUS * .5 * Math.random()),
          }
          planets[i] = planet;
        }
    }

  // Creating the orbit
      var paused = false;
      var last = new Date().getTime();
      var down = false;
      var sx = 0;
      var sy = 0;

      window.onmousedown = function (ev){
        down = true; sx = ev.clientX; sy = ev.clientY;
      }
      window.onmouseup = function(){down = false}
      window.onmousemove = function(ev){
        if(down){
          var dx = ev.clientX - sx;
          var dy = ev.clientY - sy;
          // console.log("X-location: " + ev.clientX);
          // console.log("Y-location: " + ev.clientY);
          rotation += dx/100;
          // console.log("rotation: " + rotation);
          camera.position.x = Math.cos(rotation)*250;
          camera.position.z = Math.sin(rotation)*250;
          camera.position.y += dy;
          // console.log("Camera X position: " + camera.position.x); 
          // console.log("Camera Z position: " + camera.position.z);
          // console.log("Camera Y position: " + camera.position.y);
          sx += dx;
          sy += dy;
        }
      }

      function cameraOrbit(t){
          if(!down){
            camera.position.set(
              Math.sin(t/1000) * 300, sy, Math.cos(t/1000) * 300);
          }
      }

      // function animate(t){
      //   console.log("animate");
      //   if(!paused){
      //     last = t;

      //     createPlanets();
      //     var speeds = [1, 1.25, 1.5, 1.75, 2, 2.5, 3];
      //     var speed;
      //     for(var i=0; len = spheres.length, i < len; i++){
      //       speed = speeds[Math.floor(Math.random() * speeds.length)];
      //       spheres[i].position.y = 60-Math.sin(t/900)*25 * speed;
      //       spheres[i].position.x = Math.cos(t/600)*85 * speed;
      //       spheres[i].position.z = Math.sin(t/600)*85 * speed;
      //     }

      //     // sphere.position.y = 60-Math.sin(t/900)*25;
      //     // sphere.position.x = Math.cos(t/600)*85;
      //     // sphere.position.z = Math.sin(t/600)*85;

      //     renderer.clear();
      //     camera.lookAt(scene.position);
      //     renderer.render(scene,camera);
      //   }
      //   window.requestAnimationFrame(animate,renderer.domElement);
      // };

      // animate(new Date().getTime());
      // cameraOrbit(new Date().getTime());
      onmessage = function(ev) {
        paused = (ev.date == 'pause');
      };

      function loop(){
          ss.angle += ss.angleIncrement;
          for(var i=0; len = spheres.length, i < len; i++){
            // spheres[i].position.y = (60-Math.sin(angle.angle)) * (planets[i].speed * speedScaler.speedScalar) * planets[i].relative;

            spheres[i].position.y = (60-Math.sin(ss.angle)) * planets[i].random + sizes[0] * planets[i].relative;

            // spheres[i].position.x = Math.cos(angle.angle * planets[i].speed)*85 * (planets[i].speed * speedScaler.speedScalar);

            spheres[i].position.x = ss.amplitude * Math.cos(planets[i].cycle*(ss.angle - ss.horizontalShift) * planets[i].speed) + ss.verticalShift;

            // spheres[i].position.z = Math.sin(angle.angle * planets[i].speed)*85 * (planets[i].speed * speedScaler.speedScalar);

            spheres[i].position.z = ss.amplitude * Math.sin(planets[i].cycle*(ss.angle - ss.horizontalShift) * planets[i].speed) + ss.verticalShift;
          }
          renderer.clear();
          camera.lookAt(scene.position);
          renderer.render(scene,camera);
      }

      init();
      function init(){
        createPlanets();
        setInterval(loop, 1000/60);
      }

      // Adds a GUI interface for changing the orbit
      var gui = new DAT.GUI();
      gui.add(ss, 'angleIncrement', 0, 1, 0.01);
      gui.add(ss, 'amplitude', 0, 200, 1);
      gui.add(ss, 'cycles', 0, 1, 0.01);
      gui.add(ss, 'period', 0, 1, .1);
      gui.add(ss, 'verticalShift', 0, 100, 1);
      gui.add(ss, 'horizontalShift', 0, 100, 1);
      gui.add(ss, 'explode');
    </script>
  </body>