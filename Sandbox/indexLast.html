<!DOCTYPE html>
<html lang="en">
	<head>
		<title>Mine</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body {
				font-family: Monospace;
				background-color: #000000;
				margin: 0px;
				overflow: hidden;
			}

			#info {
				color: #fff;
				position: absolute;
				top: 10px;
				width: 100%;
				text-align: center;
				z-index: 100;
				display:block;

			}

			a { color: skyblue }
		</style>
	</head>
	<body>
		<script src="../assets/js/three.min.js"></script>
		<!--<script src="../cameraSandbox/camMoveTests.js"></script>-->
		<script src="../modelSandbox/js/loaders/ColladaLoader.js"></script>
		<script src="../assets/js/TweenMax.js"></script>
		<script src="../assets/js/OrbitControls.js"></script>
  		<script src="../cameraSandbox/cameraSettings.js"></script>
		<script>

			var container, stats;

			var camera, scene, renderer, objects, centerSesame = new THREE.Vector3(0,0,0), cameraLine;
			var particleLight, pointLight;
			var dae, skin, sesameStoneDae;
			var directionalLight;
			var transitionFirst = true;

			var colladaRef;
			var sesameStoneRef;

		    //Planet Variables
		    var planets;
			function planet(){};
		    var PLANET_COUNT = 12;

		    //Cluster Variables
		    var clusters = [];
			var cluster_count = 3;

		    function cluster(cluster_ID){
		      this.cluster_ID     = cluster_ID;
		      this.name           = "untitled";
		      this.clusterPlanets = [];
		      this.lineMaterial   = new THREE.LineBasicMaterial({color: 0xFFFFFF});//white line material
		      this.lineStack      = [];
		    };

		    var RADIUS = 30;
		    var relatives = [1, -1];
		    var sizes  = [2,2.5,3,4,5];
		    var kuler  = ["0x14A697", "0xF2C12E", "0xF29D35", "0xF27649", "0xF25252"];

			var orbitSettings = {
				disableRotate : true,
				panMode : true
			}
		    var spheres, lines;
		    var speeds = [ .15,.25, .35, .4, .5, .6, .75, .85, 1, 1.15, 1.25, 1.5];
		    var cycles = [ .7, .75, .80, .85, .90, .95, 1.0, 1.05, 1.1, 1.15, 1.20, 1.25];
		    var speed;
		    var rotation = 1;
		    var ss = {
		      "angle": 90, 
		      "angleIncrement":0.0, 
		      "clusterAmplitude": 50, 
		      "planetAmplitude": 1, 
		      "amplitude": 3, 
		      "cycles":1,
		      "period":1,
		      "verticalShift": 0, 
		      "xShift": 0,
		      "zShift": 0, 
		      "horizontalShift": 0,
		    };

		    ss.Settings = {
		      // categories: ["living", "outside", "workshop", "food", "technology", "play"],
		      viewThreshold: 18000,
		      maxIblesPerAuthor: 30,
		      width: document.body.clientWidth,
		      height: document.body.clientHeight,
		      cameraDefaultPosition: new THREE.Vector3( 222.3842933874708, 388.94164021652136, 224.33347974950735),
		      cameraDefaultTarget: new THREE.Vector3(0, 0, 0),
		      cameraDefaultUp: (new THREE.Vector3(0, 0.93, 0.36)).normalize(),
		      cameraDefaultFOV: 45
		    };

		    ss.Status = {
		      cameraAnimating: false,
		      firstClick: false,
		    }

		    function createPlanets(){
		        planets = []; // reference from global
		        spheres = []; // reference from global
		        for(var i=0; i<PLANET_COUNT; i++){
		          //Sphere
		          var geometry   = new THREE.SphereGeometry( sizes[Math.floor(Math.random() * sizes.length)], 8, 8 );
		          var material   = new THREE.MeshBasicMaterial( {color: Number(kuler[Math.floor(Math.random() * kuler.length)])});
		          spheres[i]     = new THREE.Mesh( geometry, material );

		          //Outline
		          var outlineMaterial1 = new THREE.MeshBasicMaterial( { opacity: 0, color: 0xff0000, side: THREE.BackSide } );
		          var outlineMesh1 = new THREE.Mesh( geometry, outlineMaterial1 );
		          // console.log(outlineMesh1);
		          outlineMesh1.scale.multiplyScalar(1.1);

		          // Create a new planet reference
		          var planetSpawn = new planet();
		          planetSpawn = {
		            speed:      speeds[Math.floor(Math.random() * speeds.length)],
		            relative:   relatives[Math.floor(Math.random() * relatives.length)],
		            random:     Math.random() * speeds[speeds.length-1],
		            cycle:      cycles[Math.floor(Math.random() * cycles.length)],
		            targetSize: 1,
		            orbit:      RADIUS*.5 + (RADIUS * .5 * Math.random()),
		            geometry:   geometry,
		            material:   material,
		            sphereInitID: i,
		            sphere:     spheres[i],
		            sphereID:   spheres[i].id,
		            planetAmplitude : Math.floor(Math.random() * 20 + 5),
		            outline:    outlineMesh1,
		          }
		          scene.add(planetSpawn.sphere);
		          planets[i] = planetSpawn;
		        }

		        //take all the planets, and put them in various clusters
		        var cluster_inc  = 0;
		        var cluster_iter = 0;
		        var planet_inc   = 0;
		        
		        //while we haven't compiled every planet
		        while(planet_inc < planets.length){
		          clusters[cluster_inc] = new cluster(planet_inc);
		          clusters[cluster_inc].cluster_ID = cluster_inc; 
		          
		          //for each size of each cluster
		          for(cluster_iter = 0; ((cluster_iter < cluster_count) && (planet_inc < planets.length)); cluster_iter++){
		            //add a planet to the iterated cluster
		            // clusters[cluster_inc].clusterPlanets[cluster_iter] = planets[planet_inc];
		            planet_inc++;
		          }
		          cluster_inc++;
		        }
		    }


			var loader = new THREE.ColladaLoader();
			loader.options.convertUpAxis = true;
			loader.load( '../modelSandbox/collada/sesameStone.dae', function ( collada ) {

				sesameStoneDae = collada.scene;
				sesameStoneRef = collada;

				sesameStoneDae.scale.x = sesameStoneDae.scale.y = sesameStoneDae.scale.z = .85;
				sesameStoneDae.position.x = centerSesame.x;
				sesameStoneDae.position.z = centerSesame.z;
				sesameStoneDae.updateMatrix();

				init();
				animate();

			} );

	      function addOutline(meshRef){
	        var c=0;
	        loop1:
	        for(;c<clusters.length;c++){
	        loop2:
	          for(var p=0;p<clusters[c].clusterPlanets.length;p++){
	              // console.log(meshRef + " : " + clusters[c].clusterPlanets[p].sphere.uuid);
	              if(clusters[c].clusterPlanets[p].sphere.uuid == meshRef){
	                //once they're the same, add outline for everything in the cluster c
	                // console.log("Match! :" + meshRef + " " +  clusters[c].clusterPlanets[p].sphere.uuid);
	                break loop1;
	              }
	            }
	        }
	        // console.log("The cluster of the id that's being organized: " + c);
	        for(var p=0;p<clusters[c].clusterPlanets.length;p++){
	            scene.add(clusters[c].clusterPlanets[p].outline);
	        }
	      }

	      function removeOutline(meshRef){
	        for(var c=0;c<clusters.length;c++){
	          for(var p=0;p<clusters[c].clusterPlanets.length;p++){
	            // console.log(meshRef + " : " + clusters[c].clusterPlanets[p].sphere.uuid);
	            //once they're the same, add outline for everything in the cluster c
	            scene.remove(clusters[c].clusterPlanets[p].outline);
	            }
	        }
	      }

	      function onDocumentMouseDown( event ) {

	        event.preventDefault();

	        var vector = new THREE.Vector3( ( event.clientX / window.innerWidth ) * 2 - 1, - ( event.clientY / window.innerHeight ) * 2 + 1, 0.5 );
	        projector.unprojectVector( vector, camera );

	        var raycaster = new THREE.Raycaster( camera.position, vector.sub( camera.position ).normalize() );
	        var intersects = raycaster.intersectObjects( spheres );

	        if ( intersects.length > 0 ) {
	          //change color of planet to white
	          // console.log(intersects[0].object.id);
	          intersects[ 0 ].object.material.color.setHex(0xffffff);
	          // console.log(intersects[ 0 ].object);
	          addOutline(intersects[0].object.uuid);

	          // zoomAndDollyToPoint(camera, intersects[0].object.id, function(){console.log("Done")}); 
	          removeOutline(intersects[0].object.uuid);
	          addOutline(intersects[0].object.uuid);
	        }
	      }

			function init() {

				//container
				container = document.createElement( 'div' );
				document.body.appendChild( container );
				scene = new THREE.Scene();

				//define and position the camera
				var VIEW_ANGLE = 45, ASPECT = window.innerWidth / window.innerHeight, NEAR = 0.1, FAR = 20000;
				camera = new THREE.PerspectiveCamera( VIEW_ANGLE, ASPECT, NEAR, FAR);
				camera.position.set( 0, 1, 0 );
				scene.add(camera);

				//generate the planets
				createPlanets();

				// Add the COLLADA
				scene.add( sesameStoneDae );

				//projector for clicking elements
		        projector = new THREE.Projector();
		        //how to respond to mouse events
		        document.addEventListener( 'mousedown', onDocumentMouseDown, false );

				// Lights
				var light = new THREE.AmbientLight( 0x404040 );
				scene.add(light);
				directionalLight = new THREE.DirectionalLight( 0xffffff, 0.5 );
				directionalLight.position.set( 0, 5, 0 );
				directionalLight.lookAt(sesameStoneDae.position);
				scene.add( directionalLight );

				//
				renderer = new THREE.WebGLRenderer();
				renderer.setSize( window.innerWidth, window.innerHeight )
				container.appendChild( renderer.domElement );

				//
				window.addEventListener( 'resize', onWindowResize, false );

				// Add the controls
				controls = new THREE.OrbitControls( camera );
				controls.minDistance = 10;
				controls.maxDistance = 150;

				//
				var clusterCenters = [];

				// Add a skybox				
				var imagePrefix = "../modelSandbox/images/darkSky_";
				var directions  = ["xpos", "xneg", "ypos", "yneg", "zpos", "zneg"];
				var imageSuffix = ".jpg";
				var skyGeometry = new THREE.CubeGeometry( 5000, 5000, 5000 );	
				
				var materialArray = [];
				for (var i = 0; i < 6; i++)
					materialArray.push( new THREE.MeshBasicMaterial({
						map: THREE.ImageUtils.loadTexture( imagePrefix + directions[i] + imageSuffix ),
						side: THREE.BackSide
					}));
				var skyMaterial = new THREE.MeshFaceMaterial( materialArray );
				var skyBox  = new THREE.Mesh(skyGeometry, skyMaterial );
				skyBox.name = "skyBox";
				scene.add( skyBox );
			}

			function onWindowResize() {
				camera.aspect = window.innerWidth / window.innerHeight;
				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			function animate() {
				setInterval(loop, 1000/60);
			}

      function loop(){
        if(ss.angleIncrement > 0){
          ss.angle += ss.angleIncrement;

          //local variable for efficiency's sake
          var clusterRef;
          var planetRef;

          //Update every planet(p) of every cluster(c) 
          for(var c=0; c < clusters.length; c++){
            clusterRef = clusters[c];
            planetRef  = clusters[c].clusterPlanets[0];

            //Give each central planet a color
            clusters[c].clusterPlanets[0].sphere.material.color.setRGB(1,0,0); 
            //update orbit around universal center (0,0,0)
            planetRef.outline.position.y = planetRef.sphere.position.y = (60-Math.sin(ss.angle)) * planetRef.random + sizes[0] * planetRef.relative;
            planetRef.outline.position.x = planetRef.sphere.position.x = (ss.clusterAmplitude ) * Math.cos(planetRef.cycle*(ss.angle - ss.horizontalShift) * planetRef.speed) + ss.verticalShift;
            planetRef.outline.position.z = planetRef.sphere.position.z = (ss.clusterAmplitude ) * Math.sin(planetRef.cycle*(ss.angle - ss.horizontalShift) * planetRef.speed) + ss.verticalShift;         

            //iterate through every every planet of every cluster
            for(var p=1; p < clusters[c].clusterPlanets.length; p++){
              planetRef = clusterRef.clusterPlanets[p];

              // udpate x,y and z around central orbit
              // planetRef.sphere.position.y = (60-Math.sin(ss.angle)) * planetRef.random + sizes[0] * planetRef.relative;
              planetRef.outline.position.y = planetRef.sphere.position.y = clusterRef.clusterPlanets[0].sphere.position.y;
              planetRef.outline.position.x = planetRef.sphere.position.x = (planetRef.planetAmplitude + (planetRef.planetAmplitude * ss.planetAmplitude)) * Math.cos(planetRef.cycle*(ss.angle - ss.horizontalShift) * planetRef.speed) + ss.verticalShift + clusterRef.clusterPlanets[0].sphere.position.x;
              planetRef.outline.position.z = planetRef.sphere.position.z = (planetRef.planetAmplitude + (planetRef.planetAmplitude * ss.planetAmplitude)) * Math.sin(planetRef.cycle*(ss.angle - ss.horizontalShift) * planetRef.speed) + ss.verticalShift + clusterRef.clusterPlanets[0].sphere.position.z;
            
              //change the intra-cluster network
              clusterRef.lineStack[p].geometry.dynamic = true;
              clusterRef.lineStack[p].geometry.vertices[0].set(clusterRef.clusterPlanets[0].sphere.position.x,clusterRef.clusterPlanets[0].sphere.position.y,clusterRef.clusterPlanets[0].sphere.position.z);
              clusterRef.lineStack[p].geometry.vertices[1].set(planetRef.sphere.position.x,planetRef.sphere.position.y,planetRef.sphere.position.z);
              clusterRef.lineStack[p].geometry.verticesNeedUpdate = true;
            }
          }
          //Renderer Animation managment
          renderer.clear();
          renderer.render(scene,camera);
        }
      }

		</script>
	</body>
</html>
